// Export Helper - PDF and Image Export
const PDFDocument = require('pdfkit');
const fs = require('fs');
const { dialog } = require('electron');
const path = require('path');

class ExportHelper {
    static async exportToPDF(data) {
        try {
            const { filePath, canceled } = await dialog.showSaveDialog({
                title: 'Export to PDF',
                defaultPath: `${data.title || 'export'}.pdf`,
                filters: [
                    { name: 'PDF Files', extensions: ['pdf'] }
                ]
            });

            if (canceled || !filePath) {
                return null;
            }

            return new Promise((resolve, reject) => {
                const doc = new PDFDocument({
                    size: 'A4',
                    margins: { top: 50, bottom: 50, left: 50, right: 50 }
                });

                const stream = fs.createWriteStream(filePath);
                doc.pipe(stream);

                // Add header
                doc.fontSize(20)
                   .fillColor('#3f51b5')
                   .text(data.title || 'Study Buddy Export', { align: 'center' });

                doc.moveDown();

                // Add metadata
                doc.fontSize(10)
                   .fillColor('#666666')
                   .text(`Generated: ${new Date().toLocaleString()}`, { align: 'right' });

                doc.moveDown(2);

                // Add content
                doc.fontSize(12)
                   .fillColor('#000000')
                   .text(data.content, {
                       align: 'left',
                       lineGap: 5
                   });

                // Add footer
                const pageHeight = doc.page.height;
                doc.fontSize(8)
                   .fillColor('#999999')
                   .text('Generated by Study Buddy Pro', 50, pageHeight - 30, {
                       align: 'center'
                   });

                doc.end();

                stream.on('finish', () => {
                    resolve(filePath);
                });

                stream.on('error', (error) => {
                    reject(error);
                });
            });
        } catch (error) {
            console.error('PDF export error:', error);
            throw error;
        }
    }

    static async exportToImage(data) {
        // Note: Image export would require additional libraries like puppeteer or sharp
        // For now, we'll save as text file
        try {
            const { filePath, canceled } = await dialog.showSaveDialog({
                title: 'Export to Text',
                defaultPath: `${data.title || 'export'}.txt`,
                filters: [
                    { name: 'Text Files', extensions: ['txt'] }
                ]
            });

            if (canceled || !filePath) {
                return null;
            }

            const content = `${data.title}\n${'='.repeat(50)}\n\n${data.content}\n\n${'='.repeat(50)}\nGenerated by Study Buddy Pro\n${new Date().toLocaleString()}`;

            fs.writeFileSync(filePath, content, 'utf8');
            return filePath;
        } catch (error) {
            console.error('Export error:', error);
            throw error;
        }
    }

    static async exportToMarkdown(data) {
        try {
            const { filePath, canceled } = await dialog.showSaveDialog({
                title: 'Export to Markdown',
                defaultPath: `${data.title || 'export'}.md`,
                filters: [
                    { name: 'Markdown Files', extensions: ['md'] }
                ]
            });

            if (canceled || !filePath) {
                return null;
            }

            const content = `# ${data.title}\n\n${data.content}\n\n---\n*Generated by Study Buddy Pro - ${new Date().toLocaleString()}*`;

            fs.writeFileSync(filePath, content, 'utf8');
            return filePath;
        } catch (error) {
            console.error('Markdown export error:', error);
            throw error;
        }
    }
}

module.exports = ExportHelper;
